```{r setup-EinfuehrungInDieNumerik, include=FALSE}
# ---------------------------------------------------------------------------
#% maintainer:
#%   - Norman Markgraf
#%
# ---------------------------------------------------------------------------
source("../../prelude.R")
initPart(
    "00-EinfuehrungInDieNumerik",  # Dateiname ohne Suffix
    "EinfuehrungInDieNumerik"      # Verzeichnisname im Bilderverzeichnis 
    )
pathToImages = getPathToImages()
# ---------------------------------------------------------------------------

library(mosaic)

```

# {-}

\mode<all>\addtocounter{section}{-1}\renewcommand{\Sinnspruch}{
\begin{quote}
\small Über den Umgang mit ausgedruckten Ergebnissen einer numerischen Rechnung:
\begin{itemize}
  \item Der (naive) Anfänger glaubt an jede einzelne Ziffer.
  \item Der (erfahrene) Programmierer vertraut auf die Hälfte der Stellen.
  \item Der (wissende) Pessimist mißtraut sogar dem Vorzeichen.
\end{itemize}

\scriptsize -- Professor Karl Nickel (Informatikpionier der Universität Karlsruhe)  \end{quote} }\mode<*>

# `r nextChapter()` Einführung in die Numerik

\mode<all>\renewcommand{\Sinnspruch}{\relax}\mode<*>


### Spaß mit Excel

Geben Sie in Excel (oder Calc) folgende Tabelle ein:

```{r ExelFehler1,echo=FALSE, out.width = "90%", fig.align="center"}
knitr::include_graphics(file.path(pathToImages, "ExcelFehler1.png"))
```

### Spaß mit R

Runden ist in der Tat schwerer als gedacht:

```{r RundenInR}
5.000000000001-5
```

richtig wäre $`r 0.000000000001`$!

Berechnen wir $1/10$ in kompliziert:
```{r}
foo <- function(x) ((1/x)/10+1)*x-x
foo(1)
```
Aber:
```{r}
foo(1) == 0.1
```

**Warum ist das so?**

### Gleitpunktarithmetik

\begin{definition}
Eine \textbf{(normalisierte) n-stellige Gleitpunktzahl}\footnotemark\xspace zur \textbf{Basis B} hat die Form
\begin{equation*}
	x = \pm(0.z_1z_2z_3\dots z_n)_B\cdot B^E
\end{equation*}
und den Wert
\begin{equation*}
	\pm \sum_{i=1}^{n} z_i \cdot B^{E-i}
\end{equation*}
wobei $z_i \in \{0, 1, \dots, B-1\}$ und, sofern $x\neq 0$, zusätzlich$z_1 \neq 0$.

Den Anteil $(0.z_1z_2z_3\dots z_n)_B$ bezeichnen wir als \textbf{Mantisse}.

Für den \textbf{Exponenten} $E\in\mathbf{Z}$ gilt: $m \leq E \leq M$.
\end{definition}

\footnotetext{auch \textbf{Gleitkommazahl} oder \textbf{Fließkommazahl} genannt}

##### {.remark}
Eine *Gleitpunktzahl* besteht also auf dem *Vorzeichen* $v$, der *Mantisse* $(0.z_1z_2z_3\dots z_n)_B$ und dem *Exponenten* $E$ zur *Basis* $B$

### Gleitpunktarithmetik

#### {.example}
$x=-(0.2345)_{10}\cdot 10^3$ ist eine 4-stellige Gleitpunktzahl und hat den Wert $-234{,}5$.


#### {.remark}	
Übliche Basen sind $B=2$ (Dualzahlen), $B=8$ (Oktalzahlen), $B=10$ (Dezimalzahlen) und $B=16$ (Hexadezimalzahlen).


#### {.examples}
- $x=-(0.1001)_{2}\cdot 2^2$ ist eine *4-stellige duale Gleitpunktzahl* und 
	hat den Wert $-(10.01)_2=-(2.25)_{10}=-2{,}25$.
- $x=-(0.2345)_{8}\cdot 8^{-2}$ ist eine *4-stellige octale Gleitpunktzahl* und
	hat den Wert $-(0.002345)_8=-(0.004779815673828)_{10}=-0{,}004779815673828$.
- $x=(0.AFFE)_{16}\cdot 16^3$ ist eine *4-stellige hexadezimale Gleitpunktzahl* und
	hat den Wert $(AFF.E)_{16}=(2815.875)_{10}=2815,875$

### IEEE 754-2008

Die Norm **IEEE 754**\footnote{Vgl. auch \url{http://de.wikipedia.org/wiki/IEEE_754-2008}} 
(ANSI/IEEE Std 754-1985; IEC-60559:1989 - International version) definiert Standarddarstellungen 
für binäre Gleitkommazahlen in Computern und legt genaue Verfahren für die Durchführung mathematischer Operationen, 
insbesondere für Rundungen, fest. 

Der genaue Name der Norm ist englisch und lautet 
*IEEE Standard for Binary Floating-Point Arithmetic for microprocessor systems (ANSI/IEEE Std 754-1985)*.


### Übung `r nextExercise()`: Gleitpunktzahlen umrechnen {.exercise}

\begin{enumerate}[(i)]
	\item 	Welchen Wert haben die folgenden Gleitpunktzahlen im Dezimalsystem:
			\begin{equation*} 
				x_1 = 0.76005 \cdot 10^5\qquad x_2=0.571 \cdot 10^{-3}
			\end{equation*}
	\item 	Welchen Wert haben die folgenden Gleitpunktzahlen im Dualsystem:
			\begin{equation*} 
				x_1 = 0.111 \cdot 2^3\qquad x_2=0.1001 \cdot 2^{-3}
			\end{equation*}
	\item 	Wie viele Stellen $n$ werden benötigt, um die folgenden Zahlen als $n$-stellige Gleitpunktzahl im 
			Dezimalsystem darzustellen?
			\begin{equation*} 
				x_1=0{,}000100001, \quad x_2=1230001, \quad x_3=\frac{4}{5}, \quad x_4 = \frac{1}{3} 
			\end{equation*}
	\item 	Wie viele Stellen $n$ werden benötigt, um die folgenden Zahlen als $n$-stellige Gleitpunktzahl im 
			Dual	system darzustellen?
			\begin{equation*} 
				x_1=0{,}000100001, \quad x_2=1230001, \quad x_3=\frac{4}{5}, \quad x_4 = \frac{1}{3} 
			\end{equation*}
\end{enumerate}


### Maschinenzahlen

- Die Menge der auf einem Rechner darstellbaren Zahlen, die sogenannten \textbf{Maschinenzahlen}, ist endlich.
- Die Maschinenzahlen sind ungleichmäßig verteilt.
- Die größte Maschinenzahl ist $x_{max} = (1-B^{-m})B^M$.
- Die kleinste positive Maschinenzahl ist $x_{min} = B^{m-1}$
- Wenn x größer als $x_{max}$ ist  tritt ein Überlauf (*overflow*) auf und bei IEEE konformen Systemen wird *inf* zurückgegeben.
- Um positive und negative Exponenten darzustellen wird der Exponent mit einem Biaswert verrechnet: $E = e - bias$
- Das Vorzeichen wird im IEEE System mit Hilfe von $(-1)^s$, $s \in \{0, 1\}$ im Rechner abgebildet.

### Beispiel:  Maschinenzahlen in Java
\begin{tabular}{lrr}
Typ 			& \texttt{float}					& \texttt{double} 							\\
$x_{min}$ 		& $\pm 1.40239846 \cdot 10^{-45}$ 	& $\pm 4.94065458412465 \cdot 10^{-324}$ 	\\	
$x_{max}$ 		& $\pm 3.40282347 \cdot 10^{+38}$ 	& $\pm 1.79769318462315750 \cdot 10^{+308}$ \\
Dezimalstellen 	& 7									& 15 										\\
Byte 			& 4									& 8 										\\
Codierung		& IEEE 754 single					& IEEE 754 double							\\
\end{tabular}

### Offene Übung `r nextExercise()`: {.exercise}

Geben Sie fundierte Schätzungen an, wie viele Maschinenzahlen es bei 

a) 32-Bit (single), 
b) 64-Bit (double) und 
c) 128-Bit (long double)

Darstellung geben kann. Begründen Sie Ihre Schätzungen.

### Rundung, Rundungsfehler

- Beim **Runden** einer Zahl x wird die Maschinenzahl $rd(x)$ gesucht, die den kleinsten **absoluten Fehler** 
  $|x - rd(x)|$ unter allen Maschinenzahlen aufweist. (**Rundungsfehler**)

- Der **relative Fehler** einer Näherung  $rd(x)$ für $x$ ist gegeben durch:
    $$\left| \frac{x - rd(x)}{x}\right|$$

- Der maximal auftretende relative Fehler bei einer Rundung in n-stelliger Gleitpunktarithmetik ist gegeben durch $eps = \frac{B}2 B^{-n}$.  Der Wert $eps$ wird auch **Maschinengenauigkeit** genannt. Es gilt damit:
    $$rd(x) = (1 + \epsilon)\cdot x \text{ mit } |\epsilon| < eps$$

### Offene Übung `r nextExercise()`: Maschinen-Genauigkeit {.exercise .fragile}

Schreiben Sie ein Programm, welches die *Maschinengenauigkeit* **eps** berechnet.

```{r include=FALSE}
eps = 1
while ((1+eps) != 1 ) {
  eps <- eps / 2
}
eps
```

\begin{verbbox}
eps = 1
while ((1+eps) != 1 ) {
  eps <- eps / 2
}
eps
\end{verbbox}

:::::: {.notes}

Eine mögliche Lösung könnte wie folgt aussehen:

\theverbbox

Als Ergebnis würde man $eps=`r eps`$ erhalten.

::::::

### Übung `r nextExercise()`: Die Numerische Null {.exercise}

Wegen
$$
    ((1/x)/10+1)*x-x = \left(\frac{\frac{1}{x}}{10}+1\right)\cdot x - x = \frac{\frac{1}{x}}{10}\cdot x + x -x = \frac{1}{10}
$$

ist `foo(1)` mathematisch immer $0.1$.

Wie würden die Gleichheit in einem (R-)Programm am sinnvollsten abfragen:

A.  `foo(1) = 0.1`
B.  `foo(1) == 0.1`
C.  `\left| foo(1) - 0.1 \right| = 0`
D.  `\left|foo(1) - 0.1 \right| == 0`
E.  `\left|foo(1) - 0.1 \right| < eps`


### Rechenarithmetik

- Jede einzelne Operation (+,-,*,…) wird auf n+1 Stellen gerechnet und dann wird gerundet. Erst im Anschluss wird die nächste Operation durchgeführt

- Das Ergebnis einer Kette von Operationen ist das Ergebnis einer Kette von Rundungen – nicht erst das Ergebnis ist gerundet!
Bei der Addition müssen erst die Exponenten verglichen und ggfs. angepasst werden, dann können die Mantissen addiert werden. Danach wird ggfs. normalisiert

- Bei der Multiplikation werden die Exponenten addiert und die Mantissen multipliziert. Danach wird ggfs. normalisiert

### Beispiel Rechenarithmetik

Addition in n=3-stelliger Gleitpunktarithmetik im Dezimalsystem:
	
$$
    \begin{aligned}
        x = 1590 &= 0.159 \cdot 10^4; y = 4 = 0.4\cdot 10^1; z = 4 = 0.4 \cdot 10^1 \\
        x + y    &= 0.159 \cdot 10^4 + 0.4\cdot 10^1 = 0.159 \cdot 10^4 + 0.0004\cdot 10^4 \\
                 &= 0.1594 \cdot 10^4 \approx 0.159 \cdot 10^4 \\
                 &\approx 1590 \\
        (x+y)+z  &= 0.159 \cdot 10^4 + 0.4\cdot 10^1 = 0.159 \cdot 10^4 + 0.0004\cdot 10^4 \\
                 &= 0.1594 \cdot 10^4 \approx 0.159 \cdot 10^4 \\
                 &\approx 1590 \\
        x+(y+z)  &= 0.159 \cdot 10^4 + 0.8\cdot 10^1 = 0.159 \cdot 10^4 + 0.0008\cdot 10^4 \\
                 &= 0.1598 \cdot 10^4 \approx 0.160 \cdot 10^4 \\
                 &\approx 1600 \\
    \end{aligned}
$$


### Übung `r nextExercise()`:  {.exercise}

Gegeben sind die drei Werte:

$$
    \begin{aligned}
        x_1 &= 123.454 \text{ Mrd Euro} \\
        x_2 &= 123.446 \text{ Mrd Euro} \\
        x_3 &= 123.435 \text{ Mrd Euro} \\
    \end{aligned}
$$

Berechnen Sie in 5-stelliger dezimaler Gleitpunktarithmetik!

- $x_1 - x_2$
- $x_1 - x_3$

<div class="notes">
  $$
    \begin{aligned}
        x_1 - x_2   &= 0.123454 \cdot 10^6 - 0.123446 \cdot 10^6 \\ 
                    &= 0.12345 \cdot 10^6 - 0.12345 \cdot 10^6 \\
                    &= 0
    \end{aligned}
  $$
  $$
    \begin{aligned}
        x_1 - x_3   &= 0.123454 \cdot 10^6 - 0.123435 \cdot 10^6 \\
                    &= 0.12345 \cdot 10^6 - 0.12344 \cdot 10^6\\
                    &= 0.00001 \cdot 10^6 \\
                    &= 0.1 \cdot 10^2\\
                    &= 10
     \end{aligned}
  $$                  
</div>


### Fehler bei arithmetischen Operationen/ Auslöschung

Es sei $\tilde{x} = rd(x) = (1-e_x)\cdot x$ und $\tilde{y} = rd(y) = (1-e_y)\cdot y$.

- *Addition*:
    - aboluter Fehler: $\tilde{x} + \tilde{y} = x + y - e_x \cdot x - e_y \cdot y$
    - relativer Fehler: $\displaystyle \frac{x+y- (\tilde{x}+\tilde{y})}{x + y} = \frac{x}{x+y}\cdot e_x + \frac{y}{x+y}\cdot e_y$
    
- *Multiplikation*:
    - aboluter Fehler: $\tilde{x} \cdot \tilde{y} = (1-e_x-e_y+ e_x \cdot e_y) \cdot xy$
    - relativer Fehler: $\displaystyle \frac{x \cdot y- (\tilde{x} \cdot \tilde{y})}{x \cdot y} = e_x+e_y - e_x \cdot e_y$

Addition ist numerisch fehleranfälliger als Multiplikation: Hoher relativer Fehler bei Subtraktion in etwa gleich großer Zahlen (**Auslöschung**)

### Fehlerfortpflanzung bei Funktionsauswertung

Beim Auswerten einer Funktion $f$ an der (z.B. gerundeten) Stelle $\tilde{x}$ anstatt an der Stelle $x$ wirkt sich dieser Fehler natürlich auch auf den Funktionswert aus. 

Wird mit diesen (fehlerhaften) Funktionswert weitergerechnet wirkt sich dieser Fehler natürlich auch dort aus, man spricht von **Fehlerfortpflanzung**

Je nach Beschaffenheit der zugrundeliegenden Funktionen kann das Ergebnis mehr oder weniger stark fehlerbehaftet sein.

### Abschätzung und Schätzung des Fehlers bei Funktionsauswertungen

Es gelten folgende Schranken (Abschätzungen) und Schätzungen für den Fehler bei Funktionsauswertungen:

- Absoluter Fehler:
$$
    \begin{aligned}
     | f(x) - f(\tilde{x}) | &\leq M \cdot |x - \tilde{x}| \text{ mit } M = \max_{x_0 \in I} |f'(x_0)| \\
     | f(x) - f(\tilde{x}) | &\approx |f'(\tilde{x})|\cdot |x - \tilde{x}|\\
    \end{aligned}
$$


- Relativer Fehler:
$$
    \begin{aligned}
     \left| \frac{f(x) - f(\tilde{x})}{f(x)} \right| &\leq M \cdot \frac{\max_{x_0 \in I} |x_0| }{\min_{x_0 \in I} |f(x_0)|} \cdot |x - \tilde{x}| \text{ mit } M = \max_{x_0 \in I} |f'(x_0)| \\
     \left| \frac{f(x) - f(\tilde{x})}{f(x)} \right|  &\approx |f'(\tilde{x})|\cdot \frac{|\tilde{x}|}{|f(\tilde{x})|} \cdot |x - \tilde{x}|\\
    \end{aligned}
$$

### Beispiel Fehlerfortpflanzung

Es soll das Fehlerfortpflanzungverhalten der Funktion $f(x) = x^2 - 100$ an der Stelle $x=11.1$, $\tilde{x} = 11$, $I=[10.5, 11.5]$ untersucht werden:

- Für den absoluten Fehler gilt, wegen $M = \max_{x_0 \in I} |f'(x_0)| = \max_{x_0 \in I} |2 \cdot x_0| = 2 \cdot 11.5 = 23$:
$$
    \begin{aligned}
        | f(x) - f(\tilde{x}) | &\leq 23 \cdot |11.1 - 11|  = 23 \cdot 0.1 = 2.3 \\
        | f(x) - f(\tilde{x}) | &\approx |f'(\tilde{x})|\cdot |x - \tilde{x}| = 22 \cdot 0.1 = 2.2 \\
    \end{aligned}
$$

- Für den relativen Fehler gilt:
$$
    \begin{aligned}
      \left| \frac{f(x) - f(\tilde{x})}{f(x)} \right|  &\leq 23 \cdot \frac{11.5}{10.25} \cdot 0.1 = 2.580488 \\
      \left| \frac{f(x) - f(\tilde{x})}{f(x)} \right| &\approx |f'(\tilde{x})|\cdot \frac{|\tilde{x}|}{|f(\tilde{x})|} \cdot |x - \tilde{x}| = 22 \cdot \frac{11}{21} \cdot 0.1 = 1.152381 \\
    \end{aligned}
$$


### Übung `r nextExercise()`:  Fehlerfortpflanzung {.exercise}

Gegeben sei die Funktion $f(x) = \sqrt{x}$, $x = 0.01$ und $\tilde{x}=0.011$.

a) Berechnen Sie den wahren absoluten und relativen Fehler.
b) Geben Sie eine Schätzung für den absoluten und relativen Fehler an.
c) Geben Sie ein Abschätzung (Schranke) für den wahren und relativen Fehler im Intervall $I = [x, \tilde{x}]$ an.

### Das Wissen sie nun!

- Gleitpunktzahlen setzten sich zusammen aus dem Vorzeichen, der Mantisse und der Basis hoch dem Exponenten. Bei normalisierten Gleitpunktzahlen ist die erste Ziffer der Mantisse ungleich $0$.

- Die Menge der auf einen Rechner darstellbaren Zahlen ist endlich und ungleichmäßig verteilt.

- Bei arithmetischen Operationen wird nach jeder Operation zuerst auf die nächste Maschinenzahl gerundet Auslöschung kann bei der Subtraktion zweier in etwa gleich großer Zahlen auftreten und kann zu einem hohen relativen Fehler führen.

- (Rundungs-)Fehler wirken sich je nach Funktion und Auswertungsstelle unterschiedlich aus. Dabei können relative und absolute Fehler eventuell verstärkt werden.


### Hausaufgabe {.fragile}

Untersuchen Sie die folgenden Folgen auf Konvergenz in dem Sie die Folge
$(a_n)$ mit Hilfe eines Computerprogramms oder einer Tabellenkalkulation 
an den Stellen $a_{80}$ und $a_{100}$ auswerten.

Stellen Sie Vermutungen über den Grenzwert an!

Es sei dazu
\begin{equation*}
	f(x,y) = 108 - \frac{815-\frac{1500}{y}}{x}
\end{equation*}
und die Folge durch
\begin{equation*}
	a_0 = 4;\quad a_1 = 4{,}25;\quad a_{n+1} = f(a_n, a_{n-1})
\end{equation*}
gegeben.


```{r include=FALSE}
f <- function(x,y) 108-((815-1500/y)/x)

a <- c(4, 4.25)
for(i in 1:100) {
    a <- c(a, f(a[i], a[i+1]))
}
```

\begin{verbbox}
f <- function(x, y) 108-((815-1500/y)/x)

a <- c(4, 4.25)
for(i in 1:100) {
    a <- c(a, f(a[i], a[i+1]))
}
\end{verbbox}

::::: {.notes}

Ein Programm in R könnte wie folgt aussehen:

\theverbbox

Es liefter die Werte a[70]=`r a[70]` und a[100]=`r a[100]` ...

Aber der Grenzwert ist 5.

:::::

```{r finish-EinfuehrungInDieNumerik, include=FALSE}
rm(pathToImages)
finalizePart(partname)
```
